}
Cords=data.frame(X_cords,Y_cords)
return(Cords)
}
GenerateCords("Random", 100, 1156)
#Calculate distances between points
DistanceMatrix = function(Cords,N){
M = matrix(NA, nrow = N, ncol = N)
for(i in 1:nrow(Cords) ){
X1 = Cords[i,1]
Y1 = Cords[i,2]
for(j in 1:nrow(Cords) ){
X2 = Cords[j,1]
Y2 = Cords[j,2]
Distance = sqrt( ((Y2-Y1)^2) + ((X2-X1)^2) )
M[i,j] = Distance
}
}
return(M)
}
#we now  make a matrix for the overlaps, that each agent has with every other agent
overlapMatrix = function(Cords,N,r){
M = matrix(NA, nrow = N, ncol = N)
for(i in 1:nrow(Cords)){
X1 = Cords[i,1]
Y1 = Cords[i,2]
for(j in 1:nrow(Cords)){
X2 = Cords[j,1]
Y2 = Cords[j,2]
d = sqrt( ((Y2-Y1)^2) + ((X2-X1)^2) )
if (d < (2*r) ){
M[i,j] = (2*r^2)*(acos(d/(2*r))-(d/(2*r))*sqrt(1-(d/(2*r))^2))
} else if (j==i){
M[i,j] = pi*r^2
}
else{
M[i,j] = 0
}
}
}
return(M)
}
BridgeMatrix <- function(Cords,N,r,Type="default"){
N=nrow(Cords)
M=matrix(NA, nrow = N, ncol = N)
if(Type=="default"){
for(i in 1:nrow(Cords) ){
X1=Cords[i,1]
Y1=Cords[i,2]
for(j in 1:nrow(Cords) ){
if (j <= i){
X2=Cords[j,1]
Y2=Cords[j,2]
Distance_sq=((Y2-Y1)^2) + ((X2-X1)^2)
M[i,j]=Distance_sq
if (i != j){
M[N-i+1, N-j+1] = M[i,j]
}
}
}
}
rangeM=(M<(2*r)^2)
rangeM[rangeM==FALSE] = 0
rangeM[rangeM==TRUE] = 1
# dist 6, r 3,
}
if(Type=="Square range"){
for(i in 1:nrow(Cords) ){
X1=Cords[i,1]
Y1=Cords[i,2]
for(j in 1:nrow(Cords) ){
X2=Cords[j,1]
Y2=Cords[j,2]
if((X1-2*r)<=X2 && X2<=(X1+2*r)  &&  (Y1-2*r)<=Y2 && Y2<=(Y1+2*r)) {
M[i,j] =TRUE
}else{
M[i,j] =FALSE
}
}
rangeM=M
}
}
if(Type=="Diamond range"){
for(i in 1:nrow(Cords) ){
X1=Cords[i,1]
Y1=Cords[i,2]
for(j in 1:nrow(Cords) ){
X2=Cords[j,1]
Y2=Cords[j,2]
Manhatten_Distance_obs=sum(abs(c(X1,Y1)-(c(X2,Y2))))
if(Manhatten_Distance_obs <= 2*r){
M[i,j] =TRUE
}
if(Manhatten_Distance_obs > 2*r){
M[i,j] =FALSE
}
}
}
rangeM=M
}
return(rangeM)
}
library(ggplot2)
L <- 9
r <- 3
plot(GenerateCords("Hex", L, r_square_no_diag))
vec <- c(rep(0,(L^2-1)/2),(L^2+1)/2,rep(0,(L^2-1)/2))
Cords = GenerateCords("Square", L, r_square_no_diag)
Forsøg2 = BridgeMatrix(Cords, L, 1)%^%4*vec
N = length(Cords$X_cords)
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted grid SIR",
xlim = c(1, L), ylim = c(1, L), pty="s"
)
Row_with_connections=Forsøg2[(L^2+1)/2,]   #træk rækken med forbindelser ud
#lav en color range
palette_Func=colorRampPalette(c("black", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
#lav en color range
palette_Func=colorRampPalette(c("red", "blue"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
L <- 5
r <- 3
plot(GenerateCords("Hex", L, r_square_no_diag))
vec <- c(rep(0,(L^2-1)/2),(L^2+1)/2,rep(0,(L^2-1)/2))
Cords = GenerateCords("Square", L, r_square_no_diag)
Forsøg2 = BridgeMatrix(Cords, L, 1)%^%4*vec
N = length(Cords$X_cords)
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted grid SIR",
xlim = c(1, L), ylim = c(1, L), pty="s"
)
Row_with_connections=Forsøg2[(L^2+1)/2,]   #træk rækken med forbindelser ud
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
r <- 2
plot(GenerateCords("Hex", L, r_square_no_diag))
vec <- c(rep(0,(L^2-1)/2),(L^2+1)/2,rep(0,(L^2-1)/2))
Cords = GenerateCords("Square", L, r_square_no_diag)
Forsøg2 = BridgeMatrix(Cords, L, 1)%^%4*vec
N = length(Cords$X_cords)
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted grid SIR",
xlim = c(1, L), ylim = c(1, L), pty="s"
)
Row_with_connections=Forsøg2[(L^2+1)/2,]   #træk rækken med forbindelser ud
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
setwd("~/GitHub/Projekt2_statestik")
#### Introduction ####
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(car)
library(stringr)
library(xtable)
#### Loading the data ####
D <- read.csv("merged_data.csv", header=TRUE)
#### Changing the datatable #####
str(D)
D <- mutate(D,
across(c(dir, cond, fog, rain, ID),factor)
)
lm_max1 <- step(lm(consumption ~ dir+date, data=D), scope = ~.^2, k=log(nrow(D)), test="F")
lm_max1 <- step(lm(consumption ~ tempdif+date, data=D), scope = ~.^2, k=log(nrow(D)), test="F")
lm_max1 <- step(lm(consumption ~ temp+date, data=D), scope = ~.^2, k=log(nrow(D)), test="F")
lm_max1 <- step(lm(consumption ~ temp+dew_pt+wind_spd+hum+dir+pressure+date, data=D), scope = ~.^2, k=log(nrow(D)), test="F")
lm_max1 <- step(lm(consumption ~ temp+dew_pt+wind_spd+hum+dir+pressure+ID, data=D), scope = ~.^2, k=log(nrow(D)), test="F")
lm3 <- lm(consumption ~ date,ID, data=D)
lm3 <- lm(consumption ~ date+ID, data=D)
Anova(lm3)
AIC(lm3)
plot(D$consumption~D$tempdif, col=D$ID)
AIC(lm3)
lm3 <- lm(consumption ~ temp+ID, data=D)
Anova(lm3)
AIC(lm3)
