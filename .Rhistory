} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
#lav en color range
palette_Func=colorRampPalette(c("red", "blue"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
L <- 5
r <- 3
plot(GenerateCords("Hex", L, r_square_no_diag))
vec <- c(rep(0,(L^2-1)/2),(L^2+1)/2,rep(0,(L^2-1)/2))
Cords = GenerateCords("Square", L, r_square_no_diag)
Forsøg2 = BridgeMatrix(Cords, L, 1)%^%4*vec
N = length(Cords$X_cords)
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted grid SIR",
xlim = c(1, L), ylim = c(1, L), pty="s"
)
Row_with_connections=Forsøg2[(L^2+1)/2,]   #træk rækken med forbindelser ud
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
r <- 2
plot(GenerateCords("Hex", L, r_square_no_diag))
vec <- c(rep(0,(L^2-1)/2),(L^2+1)/2,rep(0,(L^2-1)/2))
Cords = GenerateCords("Square", L, r_square_no_diag)
Forsøg2 = BridgeMatrix(Cords, L, 1)%^%4*vec
N = length(Cords$X_cords)
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted grid SIR",
xlim = c(1, L), ylim = c(1, L), pty="s"
)
Row_with_connections=Forsøg2[(L^2+1)/2,]   #træk rækken med forbindelser ud
#lav en color range
palette_Func=colorRampPalette(c("blue", "red"),bias=0.5)
myPalette=palette_Func(max(Row_with_connections))
Cols = c(rep(0,N))
for(i in 1:N){
if (Row_with_connections[i] == 0){
Cols[i] = myPalette[1]
} else {
Cols[i] = myPalette[Row_with_connections[i]]
}
}
#plot dem en efter en med color rangen
points(
c(Cords$X_cords),
c(Cords$Y_cords),
col=Cols,
pch=16
)
#Colours the points in a gradient
col_plot_func <- function(Data_vec,cords,col_vec, gradient_vals){
col_func=colorRampPalette(col_vec)
generated_cols=col_func(length(gradient_vals))
for(i in 1:length(generated_cols)){
current_col=generated_cols[i]
current_gradient_val=  gradient_vals[i]
for(j in 1:length(Data_vec)){
current_datapoint = Data_vec[j]
if (current_datapoint >= current_gradient_val){
points(cords[j,], col= current_col, pch=19)
}
}
}
}
#weighted cords plotting function
WeightPlotter <- function(Cords,N,L,r, DistM,infected_index){
require(viridis)
I_wight_vec=rep(0,N)
for(i in 1:nrow(Cords)){
for(j in 1:nrow(Cords)){
if (DistM[i,j]<=r && (j  %in% infected_index) && !(i  %in% infected_index)) {
I_wight_vec[i]=I_wight_vec[i]+1
}
}
}
Cols=viridis::viridis(max(I_wight_vec),direction=-1,begin=0.5,end=1)
par(bg = 'lightgray')
par(bg = 'lightgray')
plot(1, type = "n",
xlab = "X", ylab = "Y", main="Weighted I pressure",
xlim = c(0, L), ylim = c(0, L),
)
grid(50,50,lwd = 0.5, col = 'gray',lty = 'solid')
for(i in 1:nrow(Cords)){
if(!(i %in% infected_index)){
if(I_wight_vec[i]==0){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels="Ø", cex=0.8,col="black")
}else{
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col=Cols[I_wight_vec[i]],cex=2.5)
text(c(Cords$X_cords[i]),c(Cords$Y_cords[i]), labels=I_wight_vec[i], cex=0.8,col="black")
}
}
}
for(i in 1:nrow(Cords)){
if(i %in% infected_index){
points(c(Cords$X_cords[i]),c(Cords$Y_cords[i]),pch=16,col="red",cex=2.5)
}
}
}
#### Loading and mutating/formating the data ####
## Reading in the libraries
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(car)
library(stringr)
library(xtable)
library(lubridate)
## Reading in the data
D <- read.csv("merged_data.csv", header=TRUE)
## Setting the datatypes
# Setting the factors
D <- mutate(D, across(c(dir, cond, fog, rain, ID),factor))
# Setting the dates
D$date <- as.POSIXct(D$date, tz = "UTC")
## Mutating the data
# Adding temp difference column to the dataframe
D$tempdif <- 21 - D$temp
# Adding the weekends as a column
is_weekend <- function(date){
number_day_df <- wday(date, label=T)
number_day_char <- as.character(number_day_df)
return(number_day_char)
}
D <- mutate(D, weekday=is_weekend(date)) %>%
mutate(weekend = ifelse(weekday %in% c("lø","sø"),"weekend","workingday"))
# getting start/end of month int (mutating the date variable)
D <- mutate(D, dag=str_split_fixed(date,"-",3)[ ,3])
D <- mutate(D, start_or_end = ifelse(as.integer(dag)<15, "START","END")) %>%
mutate(start_or_end = factor(start_or_end))
## Removing non important columns
D <- select(D,!c("temp","dag","weekday", "date"))
plot(D,col=D$ID,main="Pairsplot of data")
setwd("~/GitHub/Projekt2_statestik")
#### Loading and mutating/formating the data ####
## Reading in the libraries
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(car)
library(stringr)
library(xtable)
library(lubridate)
## Reading in the data
D <- read.csv("merged_data.csv", header=TRUE)
## Setting the datatypes
# Setting the factors
D <- mutate(D, across(c(dir, cond, fog, rain, ID),factor))
# Setting the dates
D$date <- as.POSIXct(D$date, tz = "UTC")
## Mutating the data
# Adding temp difference column to the dataframe
D$tempdif <- 21 - D$temp
# Adding the weekends as a column
is_weekend <- function(date){
number_day_df <- wday(date, label=T)
number_day_char <- as.character(number_day_df)
return(number_day_char)
}
D <- mutate(D, weekday=is_weekend(date)) %>%
mutate(weekend = ifelse(weekday %in% c("lø","sø"),"weekend","workingday"))
# getting start/end of month int (mutating the date variable)
D <- mutate(D, dag=str_split_fixed(date,"-",3)[ ,3])
D <- mutate(D, start_or_end = ifelse(as.integer(dag)<15, "START","END")) %>%
mutate(start_or_end = factor(start_or_end))
## Removing non important columns
D <- select(D,!c("temp","dag","weekday", "date"))
plot(D,col=D$ID,main="Pairsplot of data")
# find the normalised data
mean_each <- group_by(D, ID) %>%
summarise(mean_each = mean(consumption))
D_with_mean <- inner_join(mean_each, D, "ID")
D <- mutate(D_with_mean, ncons = consumption/mean_each)
## Removing non important columns
D <- select(D,!c("mean_each","consumption"))
plot(D,col=D$ID,main="Pairsplot of data")
#### Loading and mutating/formating the data ####
## Reading in the libraries
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(car)
library(stringr)
library(xtable)
library(lubridate)
## Reading in the data
D <- read.csv("merged_data.csv", header=TRUE)
## Setting the datatypes
# Setting the factors
D <- mutate(D, across(c(dir, cond, fog, rain, ID),factor))
# Setting the dates
D$date <- as.POSIXct(D$date, tz = "UTC")
## Mutating the data
# Adding temp difference column to the dataframe
D$tempdif <- 21 - D$temp
# Adding the weekends as a column
is_weekend <- function(date){
number_day_df <- wday(date, label=T)
number_day_char <- as.character(number_day_df)
return(number_day_char)
}
D <- mutate(D, weekday=is_weekend(date)) %>%
mutate(weekend = ifelse(weekday %in% c("lø","sø"),"weekend","workingday"))
# getting start/end of month int (mutating the date variable)
D <- mutate(D, dag=str_split_fixed(date,"-",3)[ ,3])
D <- mutate(D, start_or_end = ifelse(as.integer(dag)<15, "START","END")) %>%
mutate(start_or_end = factor(start_or_end))
plot(D,col=D$ID,main="Pairsplot of data")
#### Loading and mutating/formating the data ####
## Reading in the libraries
rm(list=ls())
library(tidyverse)
library(ggplot2)
library(car)
library(stringr)
library(xtable)
library(lubridate)
## Reading in the data
D <- read.csv("merged_data.csv", header=TRUE)
## Setting the datatypes
# Setting the factors
D <- mutate(D, across(c(dir, cond, fog, rain, ID),factor))
# Setting the dates
D$date <- as.POSIXct(D$date, tz = "UTC")
## Mutating the data
# Adding temp difference column to the dataframe
D$tempdif <- 21 - D$temp
# Adding the weekends as a column
is_weekend <- function(date){
number_day_df <- wday(date, label=T)
number_day_char <- as.character(number_day_df)
return(number_day_char)
}
D <- mutate(D, weekday=is_weekend(date)) %>%
mutate(weekend = ifelse(weekday %in% c("lø","sø"),"weekend","workingday"))
# getting start/end of month int (mutating the date variable)
D <- mutate(D, dag=str_split_fixed(date,"-",3)[ ,3])
D <- mutate(D, start_or_end = ifelse(as.integer(dag)<15, "START","END")) %>%
mutate(start_or_end = factor(start_or_end))
## Removing non important columns
D <- select(D,!c("temp","dag","weekday", "date"))
#plot(D,col=D$ID,main="Pairsplot of data")
# find the normalised data
mean_each <- group_by(D, ID) %>%
summarise(mean_each = mean(consumption))
D_with_mean <- inner_join(mean_each, D, "ID")
D <- mutate(D_with_mean, ncons = consumption/mean_each)
## Removing non important columns
D2 <- select(D,!c("mean_each","consumption"))
plot(D2,main="Pairsplot of data")
